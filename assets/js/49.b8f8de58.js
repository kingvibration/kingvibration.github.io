(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{611:function(t,a,s){"use strict";s.r(a);var v=s(42),n=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"html-html5中的form怎么关闭自动完成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html-html5中的form怎么关闭自动完成"}},[t._v("#")]),t._v(" [html] html5中的form怎么关闭自动完成？")]),t._v(" "),s("p",[t._v('h5新增的补全功能，菜鸟教程上写的比较含糊比较难懂；\n解释： 在部分浏览器上，foucs输入框可以把之前输入过的值自动填入，如果不想自动填入，可以关掉它；\nautocomplete="off"\n默认是"on" 开启状态')]),t._v(" "),s("p",[t._v("一般业务下不会调整这个自动完成，因为对产品来说简化用户操作，建议打开")]),t._v(" "),s("h2",{attrs:{id:"css-before和-after中单冒号和双冒号的区别是什么-这两个伪元素有什么作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-before和-after中单冒号和双冒号的区别是什么-这两个伪元素有什么作用"}},[t._v("#")]),t._v(" [css] ::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？")]),t._v(" "),s("ol",[s("li",[t._v(":表示伪类，是一种样式，比如:hover, :active等")]),t._v(" "),s("li",[t._v("::表示伪元素，是具体的内容，比如::before是在元素前面插入内容，::after则是在元素后面插入内容，不过需要content配合，并且插入的内容是inline的。")]),t._v(" "),s("li",[t._v(":before和:after其实还是表示伪元素，在css3中已经修订为::before和::after了，只是为了能兼容IE浏览器，所以也可以表示成:before和:after")])]),t._v(" "),s("h2",{attrs:{id:"js-说说你对javascript的作用域的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-说说你对javascript的作用域的理解"}},[t._v("#")]),t._v(" [js] 说说你对javascript的作用域的理解")]),t._v(" "),s("ol",[s("li",[t._v("全局作用域。这个没啥说的，就是在顶层环境中申明的变量都是全局作用域，他们的属性其实都在window对象下面。")]),t._v(" "),s("li",[t._v("函数作用域。在函数内部定义的变量都是函数作用域，只能在函数中访问到，当然也可以通过闭包来访问。除此之外，在其他地方是没法访问函数内部的变量的。\n局部作用域。es6中新增的特性，弥补了以前只能使用匿名及时运行函数来创建局部变量的缺陷。使用很简单，直接用let来申明变量就行。也可以使用const来申明变量，表明这是常数。\n作用域链。要说清这个，需要首先明白javascript的代码运行过程。假设现在有个函数funcA，在该函数内部申明了一个局部变量a，在函数内部又定义了一个函数funcB，在函数B中申明了变量b。如下：")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("funcA")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("funcB")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("当进入funcA时，这时候会把变量a压入当前的作用域A中，并且将作用域A入栈，当进入funcB时，则会把变量b压入当前的作用域B中，并且将作用域B入栈，那么这时候栈中就有了作用域A和作用域B，当在funcB中查找某个变量时，会先从当前的作用域B中查找，如果没有的话，那么就根据栈中的作用域依次往上查找，这就是作用域链。")]),t._v(" "),s("p",[t._v("作用域")]),t._v(" "),s("p",[t._v("作用域是一组规则，决定了一个变量（标识符）在哪里和如何被查找。")]),t._v(" "),s("p",[t._v("查找变量用于赋值，变量是一个 LHS（左手边）引用；查找变量用于取值，变量是一个 RHS（右手边）引用。")]),t._v(" "),s("p",[t._v("LHS 和 RHS 引用查询都从当前执行中的作用域开始，它们会在嵌套的作用域中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到。")]),t._v(" "),s("p",[t._v("未找到的 RHS 引用会导致 ReferenceError 被抛出。")]),t._v(" "),s("p",[t._v("未找到的 LHS 引用会导致一个自动的，隐含地创建的同名全局变量（如果不是“Strict模式”），或者一个 ReferenceError（“Strict模式”）。")]),t._v(" "),s("p",[t._v("词法作用域")]),t._v(" "),s("p",[t._v("js采用词法作用域，意味着作用域是由编写时函数被声明的位置决定。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并在执行期间预测它们将如何被查询。（例外是eval(),with，不推荐使用）\n函数作用域和块作用域")]),t._v(" "),s("p",[t._v("在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。")]),t._v(" "),s("p",[t._v("但是函数绝不是唯一的作用域单位。块儿作用域指的是这样一种想法：变量和函数可以属于任意代码块（一般来说，就是任意的 { .. }。")]),t._v(" "),s("p",[t._v("从 ES3 开始，try/catch 结构在 catch 子句上拥有块儿作用域。")]),t._v(" "),s("p",[t._v("在 ES6 中，引入了 let 关键字（var 关键字的表兄弟）允许在任意代码块中声明变量。if (..) { let a = 2; } 将会声明变量 a，而它实质上劫持了 if 的 { .. } 块儿的作用域，并将自己附着在这里。")]),t._v(" "),s("h2",{attrs:{id:"软技能-http都有哪些状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#软技能-http都有哪些状态码"}},[t._v("#")]),t._v(" [软技能] http都有哪些状态码？")]),t._v(" "),s("p",[t._v("常见状态码")]),t._v(" "),s("p",[t._v("2xx 成功")]),t._v(" "),s("p",[t._v("3xx 重定向")]),t._v(" "),s("p",[t._v("4xx 未找到资源")]),t._v(" "),s("p",[t._v("5xx 服务器异常")]),t._v(" "),s("p",[t._v("200 成功")]),t._v(" "),s("p",[t._v("301 重定向")]),t._v(" "),s("p",[t._v("304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。")]),t._v(" "),s("p",[t._v("400 (错误请求) 服务器不理解请求的语法。")]),t._v(" "),s("p",[t._v("403 (禁止) 服务器拒绝请求。")]),t._v(" "),s("p",[t._v("404 (未找到) 服务器找不到请求的网页。")]),t._v(" "),s("p",[t._v("500 (服务器内部错误) 服务器遇到错误，无法完成请求。")]),t._v(" "),s("p",[t._v("501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。")]),t._v(" "),s("p",[t._v("502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。")]),t._v(" "),s("p",[t._v("503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。")]),t._v(" "),s("p",[t._v("504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。")]),t._v(" "),s("p",[t._v("505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。")])])}),[],!1,null,null,null);a.default=n.exports}}]);